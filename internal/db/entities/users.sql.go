// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package entities

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (first_name, last_name, email, password, org_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_at, updated_at, org_id, email, first_name, last_name, password, is_active, is_verified
`

type CreateUserParams struct {
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	Email     string    `json:"email"`
	Password  string    `json:"password"`
	OrgID     uuid.UUID `json:"org_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.OrgID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsActive,
		&i.IsVerified,
	)
	return i, err
}

const getAuthUserByEmail = `-- name: GetAuthUserByEmail :one
SELECT
	usr.id, usr.created_at, usr.updated_at, usr.org_id, usr.email, usr.first_name, usr.last_name, usr.password, usr.is_active, usr.is_verified,
	json_agg(team.*) AS teams,
  json_agg(account.*) AS oauth_accounts,
  json_build_object(
    'id', org.id,
    'created_at', org.created_at,
    'updated_at', org.updated_at,
    'name', org.name,
    'domain', org.domain,
    'slug', org.slug
  ) AS org
FROM users AS usr
LEFT JOIN team_users AS tu
  ON usr.id = tu.user_id
LEFT JOIN teams AS team
  ON tu.team_id = team.id
LEFT JOIN oauth_accounts AS account
  ON usr.id = account.user_id
JOIN orgs AS org
  ON usr.org_id = org.id
WHERE
  usr.email = LOWER($1)
GROUP BY
  usr.id, org.id
`

type GetAuthUserByEmailRow struct {
	ID            uuid.UUID `json:"id"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	OrgID         uuid.UUID `json:"org_id"`
	Email         string    `json:"email"`
	FirstName     string    `json:"first_name"`
	LastName      string    `json:"last_name"`
	Password      string    `json:"password"`
	IsActive      bool      `json:"is_active"`
	IsVerified    bool      `json:"is_verified"`
	Teams         []byte    `json:"teams"`
	OauthAccounts []byte    `json:"oauth_accounts"`
	Org           []byte    `json:"org"`
}

func (q *Queries) GetAuthUserByEmail(ctx context.Context, lower string) (GetAuthUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getAuthUserByEmail, lower)
	var i GetAuthUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsActive,
		&i.IsVerified,
		&i.Teams,
		&i.OauthAccounts,
		&i.Org,
	)
	return i, err
}

const getAuthUserByID = `-- name: GetAuthUserByID :one
SELECT
	usr.id, usr.created_at, usr.updated_at, usr.org_id, usr.email, usr.first_name, usr.last_name, usr.password, usr.is_active, usr.is_verified,
	json_agg(team.*) AS teams,
  json_agg(account.*) AS oauth_accounts,
  json_build_object(
    'id', org.id,
    'created_at', org.created_at,
    'updated_at', org.updated_at,
    'name', org.name,
    'domain', org.domain,
    'slug', org.slug
  ) AS org
FROM users AS usr
LEFT JOIN team_users AS tu
  ON usr.id = tu.user_id
LEFT JOIN teams AS team
  ON tu.team_id = team.id
LEFT JOIN oauth_accounts AS account
  ON usr.id = account.user_id
JOIN orgs AS org
  ON usr.org_id = org.id
WHERE
  usr.id = $1
GROUP BY
  usr.id, org.id
`

type GetAuthUserByIDRow struct {
	ID            uuid.UUID `json:"id"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	OrgID         uuid.UUID `json:"org_id"`
	Email         string    `json:"email"`
	FirstName     string    `json:"first_name"`
	LastName      string    `json:"last_name"`
	Password      string    `json:"password"`
	IsActive      bool      `json:"is_active"`
	IsVerified    bool      `json:"is_verified"`
	Teams         []byte    `json:"teams"`
	OauthAccounts []byte    `json:"oauth_accounts"`
	Org           []byte    `json:"org"`
}

func (q *Queries) GetAuthUserByID(ctx context.Context, id uuid.UUID) (GetAuthUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getAuthUserByID, id)
	var i GetAuthUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsActive,
		&i.IsVerified,
		&i.Teams,
		&i.OauthAccounts,
		&i.Org,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, created_at, updated_at, org_id, email, first_name, last_name, password, is_active, is_verified
FROM users
WHERE email = LOWER($1)
`

func (q *Queries) GetUserByEmail(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsActive,
		&i.IsVerified,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_at, updated_at, org_id, email, first_name, last_name, password, is_active, is_verified
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsActive,
		&i.IsVerified,
	)
	return i, err
}

const getUserByProviderAccount = `-- name: GetUserByProviderAccount :one
SELECT
  usr.id, usr.created_at, usr.updated_at, usr.org_id, usr.email, usr.first_name, usr.last_name, usr.password, usr.is_active, usr.is_verified
FROM
  users usr
JOIN
  oauth_accounts act ON usr.id = act.user_id
WHERE
  act.provider = $1 AND act.provider_account_id = $2
`

type GetUserByProviderAccountParams struct {
	Provider          string `json:"provider"`
	ProviderAccountID string `json:"provider_account_id"`
}

func (q *Queries) GetUserByProviderAccount(ctx context.Context, arg GetUserByProviderAccountParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByProviderAccount, arg.Provider, arg.ProviderAccountID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsActive,
		&i.IsVerified,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET first_name = $2, last_name = $3, email = LOWER($4), org_id = $5
WHERE id = $1
RETURNING id, created_at, updated_at, org_id, email, first_name, last_name, password, is_active, is_verified
`

type UpdateUserParams struct {
	ID        uuid.UUID `json:"id"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	Lower     string    `json:"lower"`
	OrgID     uuid.UUID `json:"org_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Lower,
		arg.OrgID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsActive,
		&i.IsVerified,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password = $2
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID       uuid.UUID `json:"id"`
	Password string    `json:"password"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.Password)
	return err
}
