// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: repos.sql

package entities

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createRepo = `-- name: CreateRepo :one
INSERT INTO repos (org_id, name, provider, provider_id, default_branch, is_monorepo, threshold, stale_duration)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, org_id, name, provider, provider_id, default_branch, is_monorepo, threshold, stale_duration
`

type CreateRepoParams struct {
	OrgID         uuid.UUID       `json:"org_id"`
	Name          string          `json:"name"`
	Provider      string          `json:"provider"`
	ProviderID    string          `json:"provider_id"`
	DefaultBranch string          `json:"default_branch"`
	IsMonorepo    bool            `json:"is_monorepo"`
	Threshold     int32           `json:"threshold"`
	StaleDuration pgtype.Interval `json:"stale_duration"`
}

func (q *Queries) CreateRepo(ctx context.Context, arg CreateRepoParams) (Repo, error) {
	row := q.db.QueryRow(ctx, createRepo,
		arg.OrgID,
		arg.Name,
		arg.Provider,
		arg.ProviderID,
		arg.DefaultBranch,
		arg.IsMonorepo,
		arg.Threshold,
		arg.StaleDuration,
	)
	var i Repo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Name,
		&i.Provider,
		&i.ProviderID,
		&i.DefaultBranch,
		&i.IsMonorepo,
		&i.Threshold,
		&i.StaleDuration,
	)
	return i, err
}

const deleteRepo = `-- name: DeleteRepo :exec
DELETE FROM repos
WHERE id = $1
`

func (q *Queries) DeleteRepo(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRepo, id)
	return err
}

const getOrgRepos = `-- name: GetOrgRepos :many
SELECT id, created_at, updated_at, org_id, name, provider, provider_id, default_branch, is_monorepo, threshold, stale_duration
FROM repos 
WHERE org_id = $1
`

func (q *Queries) GetOrgRepos(ctx context.Context, orgID uuid.UUID) ([]Repo, error) {
	rows, err := q.db.Query(ctx, getOrgRepos, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repo
	for rows.Next() {
		var i Repo
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrgID,
			&i.Name,
			&i.Provider,
			&i.ProviderID,
			&i.DefaultBranch,
			&i.IsMonorepo,
			&i.Threshold,
			&i.StaleDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepoByID = `-- name: GetRepoByID :one
SELECT id, created_at, updated_at, org_id, name, provider, provider_id, default_branch, is_monorepo, threshold, stale_duration
FROM repos
WHERE id = $1
`

func (q *Queries) GetRepoByID(ctx context.Context, id uuid.UUID) (Repo, error) {
	row := q.db.QueryRow(ctx, getRepoByID, id)
	var i Repo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Name,
		&i.Provider,
		&i.ProviderID,
		&i.DefaultBranch,
		&i.IsMonorepo,
		&i.Threshold,
		&i.StaleDuration,
	)
	return i, err
}

const listRepos = `-- name: ListRepos :many
SELECT id, created_at, updated_at, org_id, name, provider, provider_id, default_branch, is_monorepo, threshold, stale_duration
FROM repos
ORDER BY created_at DESC
`

func (q *Queries) ListRepos(ctx context.Context) ([]Repo, error) {
	rows, err := q.db.Query(ctx, listRepos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repo
	for rows.Next() {
		var i Repo
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrgID,
			&i.Name,
			&i.Provider,
			&i.ProviderID,
			&i.DefaultBranch,
			&i.IsMonorepo,
			&i.Threshold,
			&i.StaleDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepo = `-- name: UpdateRepo :one
UPDATE repos
SET org_id = $2,
    name = $3,
    provider = $4,
    provider_id = $5,
    default_branch = $6,
    is_monorepo = $7,
    threshold = $8,
    stale_duration = $9
WHERE id = $1
RETURNING id, created_at, updated_at, org_id, name, provider, provider_id, default_branch, is_monorepo, threshold, stale_duration
`

type UpdateRepoParams struct {
	ID            uuid.UUID       `json:"id"`
	OrgID         uuid.UUID       `json:"org_id"`
	Name          string          `json:"name"`
	Provider      string          `json:"provider"`
	ProviderID    string          `json:"provider_id"`
	DefaultBranch string          `json:"default_branch"`
	IsMonorepo    bool            `json:"is_monorepo"`
	Threshold     int32           `json:"threshold"`
	StaleDuration pgtype.Interval `json:"stale_duration"`
}

func (q *Queries) UpdateRepo(ctx context.Context, arg UpdateRepoParams) (Repo, error) {
	row := q.db.QueryRow(ctx, updateRepo,
		arg.ID,
		arg.OrgID,
		arg.Name,
		arg.Provider,
		arg.ProviderID,
		arg.DefaultBranch,
		arg.IsMonorepo,
		arg.Threshold,
		arg.StaleDuration,
	)
	var i Repo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
		&i.Name,
		&i.Provider,
		&i.ProviderID,
		&i.DefaultBranch,
		&i.IsMonorepo,
		&i.Threshold,
		&i.StaleDuration,
	)
	return i, err
}
