package gcp

import (
	"context"
	"encoding/json"
	"errors"
	"strconv"
	"strings"
	"time"

	"cloud.google.com/go/iam/apiv1/iampb"
	run "cloud.google.com/go/run/apiv2"
	"cloud.google.com/go/run/apiv2/runpb"
	"github.com/gocql/gocql"
	"go.breu.io/ctrlplane/internal/core"
	"go.breu.io/ctrlplane/internal/shared"
	"go.temporal.io/sdk/workflow"
)

type (
	CloudRunConstructor struct {
	}

	CloudRun struct {
		ID                         gocql.UUID
		Cpu                        string
		Memory                     string
		Generation                 string
		Envs                       map[string]string
		OutputEnvs                 map[string]string
		Region                     string // from blueprint
		Image                      string // from workload
		Config                     string
		Name                       string
		Revision                   string
		LastRevision               string
		MinInstances               int32
		MaxInstances               int32
		AllowUnauthenticatedAccess bool
		Project                    string
		ServiceName                string
	}

	Workload struct {
		Name  string `json:"name"`
		Image string `json:"image"`
	}

	// AutoGenerated struct {
	// 	Properties struct {
	// 		Generation string `json:"generation"`
	// 		CPU        string `json:"cpu"`
	// 		Memory     string `json:"memory"`
	// 	} `json:"properties"`
	// 	Output struct {
	// 		Env []struct {
	// 			URL string `json:"url"`
	// 		} `json:"env"`
	// 	} `json:"output"`
	// }

	// config struct {
	// 	properties struct {
	// 		generation string `json:generation`
	// 		cpu        string `json:cpu`
	// 		memory     string `json:memory`
	// 	}
	// 	output struct {
	// 		env map[string]string
	// 	}
	// }

	GCPConfig struct {
		Project string
	}
)

func (c *CloudRunConstructor) Create(name string, region string, config string, providerConfig string) (core.CloudResource, error) {
	cr := &CloudRun{Name: name, Region: region, Config: config}
	cr.AllowUnauthenticatedAccess = true
	cr.Cpu = "2000m"
	cr.Memory = "1024Mi"
	cr.MinInstances = 1
	cr.MaxInstances = 8

	pconfig := new(GCPConfig)
	err := json.Unmarshal([]byte(providerConfig), pconfig)
	if err != nil {
		shared.Logger().Error("Unable to parse provider config for cloudrun")
		return nil, err
	}

	cr.Project = pconfig.Project

	shared.Logger().Info("cloud run", "object", providerConfig, "umarshaled", pconfig, "project", cr.Project)
	return cr, nil
}

func (c *CloudRunConstructor) CreateFromJson(data []byte) core.CloudResource {
	cr := &CloudRun{}
	json.Unmarshal(data, cr)
	return cr
}

func (r *CloudRun) Marshal() ([]byte, error) {
	return json.Marshal(r)
}

func (r *CloudRun) Provision(ctx workflow.Context) error {

	// do nothing, the infra will be provisioned with deployment
	return nil
}

func (w *Workflows) ProvisionCloudRun(ctx workflow.Context, r *CloudRun) error {

	shared.Logger().Info("Provisioning cloud run resource", "name", r.Name, "region", r.Region, "config", r.Config)

	return nil
}

func (r *CloudRun) Deploy(ctx workflow.Context, wl []core.Workload) error {
	shared.Logger().Info("deploying", "cloudrun", r, "workload", wl)

	if len(wl) != 1 {
		shared.Logger().Error("Cannot deploy more than one workloads on cloud run", "number of workloads", len(wl))
		return errors.New("multiple workloads defined for cloud run")
	}

	// provision with execute a workflow to provision the resources. This workflow is not directly called
	// from provisioninfra workflow to avoid passing resource interface as argument
	w := &Workflows{}

	opts := shared.Temporal().
		Queue(shared.CoreQueue).
		ChildWorkflowOptions(
			shared.WithWorkflowParent(ctx),
			shared.WithWorkflowBlock("CloudRun"),
			shared.WithWorkflowBlockID(r.Name),
			shared.WithWorkflowElement("Deploy"),
		)

	cctx := workflow.WithChildOptions(ctx, opts)

	shared.Logger().Info("starting DeployCloudRun workflow")

	err := workflow.
		ExecuteChildWorkflow(cctx, w.DeployCloudRun, r, wl[0]).Get(cctx, r)

	if err != nil {
		shared.Logger().Error("Could not start ProvisionCloudRun workflow", "error", err)
		return err
	}
	return nil
}

func (w *Workflows) DeployCloudRun(ctx workflow.Context, r *CloudRun, wl *core.Workload) (*CloudRun, error) {
	// get next revision of the resource to be deployed

	r.ServiceName = wl.Name
	activityOpts := workflow.ActivityOptions{StartToCloseTimeout: 60 * time.Second}
	actx := workflow.WithActivityOptions(ctx, activityOpts)
	err := workflow.ExecuteActivity(actx, activities.GetNextRevision, r).Get(ctx, r)
	if err != nil {
		shared.Logger().Error("Error in Executing activity: GetNextRevision", "error", err)
		return r, err
	}

	err = workflow.ExecuteActivity(actx, activities.DeployRevision, r, wl).Get(ctx, nil)
	if err != nil {
		shared.Logger().Error("Error in Executing activity: DeployDummy", "error", err)
		return r, err
	}
	return r, nil
}

func (a *Activities) GetNextRevision(ctx context.Context, r *CloudRun) (*CloudRun, error) {
	revision := r.ServiceName + "-0"
	r.LastRevision = ""
	svc := r.GetService()
	if svc != nil {
		rev := svc.Template.Revision
		r.LastRevision = rev
		ss := strings.Split(rev, r.ServiceName+"-")
		revVersion, _ := strconv.Atoi(ss[1])
		revVersion++
		revision = r.ServiceName + "-" + strconv.Itoa(revVersion)
	}
	r.Revision = revision
	shared.Logger().Info("Next revision", "name", revision)
	return r, nil
}

// DeployRevision dep
func (a *Activities) DeployRevision(ctx context.Context, r *CloudRun, wl *core.Workload) error {

	client, _ := r.GetServiceClient()
	defer client.Close()

	// If this is the first revision
	if r.Revision == wl.Name+"-0" {
		service := r.GetServiceTemplate(wl)
		shared.Logger().Info("deploying service", "data", service, "parent", r.GetParent(), "ID", wl.Name)
		csr := &runpb.CreateServiceRequest{Parent: r.GetParent(), Service: service, ServiceId: wl.Name}
		op, err := client.CreateService(ctx, csr)

		if err != nil {
			shared.Logger().Error("Create service", "Error", err)
			return err
		}

		shared.Logger().Info("waiting for service creation")
		op.Wait(ctx)
	} else {
		req := &runpb.GetServiceRequest{Name: r.GetParent() + "/services/" + wl.Name}
		service, err := client.GetService(ctx, req)

		shared.Logger().Info("20 percent traffic to latest", "revision", r.Revision)
		tt := &runpb.TrafficTarget{Type: runpb.TrafficTargetAllocationType_TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST, Percent: 50}
		tt1 := &runpb.TrafficTarget{Type: runpb.TrafficTargetAllocationType_TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION, Revision: r.LastRevision, Percent: 50}
		service.Traffic = []*runpb.TrafficTarget{tt, tt1}

		if err != nil {
			shared.Logger().Error("Get service", "Error", err)
			return err
		}

		service.Template.Revision = r.Revision
		usr := &runpb.UpdateServiceRequest{Service: service}
		op, err := client.UpdateService(ctx, usr)
		if err != nil {
			shared.Logger().Error("Update service", "Error", err)
			return err
		}

		shared.Logger().Info("waiting for service revision update")
		op.Wait(ctx)
	}

	if r.AllowUnauthenticatedAccess {
		r.AllowAccessToAll()
	}

	return nil
}

func (r *CloudRun) GetServiceClient() (*run.ServicesClient, error) {
	client, err := run.NewServicesRESTClient(context.Background())
	if err != nil {
		shared.Logger().Error("New service rest client", "error", err)
		return nil, err
	}

	return client, err
}

func (r *CloudRun) GetService() *runpb.Service {

	ctx := context.Background()

	serviceClient, err := run.NewServicesRESTClient(ctx)
	if err != nil {
		shared.Logger().Error("New service rest client", "Error", err)
		return nil
	}
	defer serviceClient.Close()

	svcpath := r.GetParent() + "/services/" + r.ServiceName
	req := &runpb.GetServiceRequest{Name: svcpath}
	svc, err := serviceClient.GetService(ctx, req)

	if err != nil {
		shared.Logger().Error("Get Service", "Error", err)
		return nil
	}

	return svc
}

// AllowAccessToAll Sets IAM policy to allow access to all users
func (r *CloudRun) AllowAccessToAll() error {

	client, err := r.GetServiceClient()
	defer client.Close()

	rsc := r.GetParent() + "/services/" + r.ServiceName
	binding := new(iampb.Binding)
	binding.Members = []string{"allUsers"}
	binding.Role = "roles/run.invoker"
	Iamreq := &iampb.SetIamPolicyRequest{Resource: rsc, Policy: &iampb.Policy{Bindings: []*iampb.Binding{binding}}}
	_, err = client.SetIamPolicy(context.Background(), Iamreq)
	if err != nil {
		shared.Logger().Error("Set policy", "Error", err)
		return err
	}
	return nil
}

func (r *CloudRun) GetServiceTemplate(wl *core.Workload) *runpb.Service {
	resourceRequirement := &runpb.ResourceRequirements{Limits: map[string]string{"cpu": r.Cpu, "memory": r.Memory}}
	crworkload := &Workload{}
	json.Unmarshal([]byte(wl.Container), crworkload)

	container := &runpb.Container{Name: wl.Name, Image: crworkload.Image,
		Resources: resourceRequirement}

	scaling := &runpb.RevisionScaling{MinInstanceCount: r.MinInstances, MaxInstanceCount: r.MaxInstances}

	rt := &runpb.RevisionTemplate{Containers: []*runpb.Container{container}, Scaling: scaling,
		ExecutionEnvironment: runpb.ExecutionEnvironment_EXECUTION_ENVIRONMENT_GEN2, Revision: r.Revision}

	service := &runpb.Service{Template: rt}
	shared.Logger().Info("full traffic to latest", "revision", r.Revision)
	tt := &runpb.TrafficTarget{Type: runpb.TrafficTargetAllocationType_TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST, Percent: 100}
	service.Traffic = []*runpb.TrafficTarget{tt}

	shared.Logger().Info("traffic", " situation", service)

	return service
}

func (r *CloudRun) GetParent() string {
	return "projects/" + r.Project + "/locations/" + r.Region
}

func (r *CloudRun) DeProvision() error {

	return nil
}
func (r *CloudRun) UpdateTraffic(ctx workflow.Context, trafficpcnt int32) error {

	// provision with execute a workflow to provision the resources. This workflow is not directly called
	// from provisioninfra workflow to avoid passing resource interface as argument
	w := &Workflows{}

	opts := shared.Temporal().
		Queue(shared.CoreQueue).
		ChildWorkflowOptions(
			shared.WithWorkflowParent(ctx),
			shared.WithWorkflowBlock("CloudRun"),
			shared.WithWorkflowBlockID(r.Name),
			shared.WithWorkflowElement("UpdateTraffic"),
		)

	cctx := workflow.WithChildOptions(ctx, opts)

	shared.Logger().Info("starting Update traffic workflow")

	err := workflow.
		ExecuteChildWorkflow(cctx, w.UpdateTraffic, r, trafficpcnt).Get(cctx, nil)

	if err != nil {
		shared.Logger().Error("Could not start ProvisionCloudRun workflow", "error", err)
		return err
	}
	return nil
}

func (a *Activities) UpdateTrafficActivity(ctx context.Context, r *CloudRun, trafficpcnt int32) error {
	service := r.GetService()
	cntxt := context.Background()
	serviceClient, err := run.NewServicesRESTClient(cntxt)
	if err != nil {
		shared.Logger().Error("New service rest client", "Error", err)
		return nil
	}
	defer serviceClient.Close()

	if r.Revision == r.ServiceName+"-0" {
		tt := &runpb.TrafficTarget{Type: runpb.TrafficTargetAllocationType_TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST, Percent: 100}
		service.Traffic = []*runpb.TrafficTarget{tt}
	} else {
		tt := &runpb.TrafficTarget{Type: runpb.TrafficTargetAllocationType_TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST, Percent: trafficpcnt}
		tt1 := &runpb.TrafficTarget{Type: runpb.TrafficTargetAllocationType_TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION, Revision: r.LastRevision, Percent: 100 - trafficpcnt}
		service.Traffic = []*runpb.TrafficTarget{tt, tt1}
	}

	req := &runpb.UpdateServiceRequest{Service: service}
	lro, err := serviceClient.UpdateService(cntxt, req)

	if err != nil {
		shared.Logger().Error("Update service", "Error", err)
		return err
	} else {
		shared.Logger().Info("waiting for service update")
		lro.Wait(cntxt)
	}
	return nil
}

func (w *Workflows) UpdateTraffic(ctx workflow.Context, r *CloudRun, trafficpcnt int32) error {

	shared.Logger().Info("Distributing traffic between revisions", r.Revision, r.LastRevision)
	activityOpts := workflow.ActivityOptions{StartToCloseTimeout: 60 * time.Second}
	actx := workflow.WithActivityOptions(ctx, activityOpts)
	err := workflow.ExecuteActivity(actx, activities.UpdateTrafficActivity, r, trafficpcnt).Get(ctx, r)
	if err != nil {
		shared.Logger().Error("Error in Executing activity: UpdateTrafficActivity", "error", err)
		return err
	}
	return nil
}
