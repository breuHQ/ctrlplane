// Package core provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package core

import (
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
	externalRef0 "go.breu.io/ctrlplane/internal/entity"
)

const (
	APIKeyAuthScopes = "APIKeyAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// StackCreateRequest defines model for StackCreateRequest.
type StackCreateRequest struct {
	Config externalRef0.StackConfig `json:"config"`
	Name   string                   `json:"name"`
}

// StackListResponse defines model for StackListResponse.
type StackListResponse = []externalRef0.Stack

// CreateStackJSONRequestBody defines body for CreateStack for application/json ContentType.
type CreateStackJSONRequestBody = StackCreateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List stacks
	// (GET /core/stacks)
	ListStacks(ctx echo.Context) error

	// Create stack
	// (POST /core/stacks)
	CreateStack(ctx echo.Context) error

	// Get stack
	// (GET /core/stacks/{slug})
	GetStack(ctx echo.Context) error

	// SecurityHandler returns the underlying Security Wrapper
	SecureHandler(handler echo.HandlerFunc, ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListStacks converts echo context to params.

func (w *ServerInterfaceWrapper) ListStacks(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(APIKeyAuthScopes, []string{""})

	// Get the handler, get the secure handler if needed and then invoke with unmarshalled params.
	handler := w.Handler.ListStacks
	secure := w.Handler.SecureHandler
	err = secure(handler, ctx)

	return err
}

// CreateStack converts echo context to params.

func (w *ServerInterfaceWrapper) CreateStack(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(APIKeyAuthScopes, []string{""})

	// Get the handler, get the secure handler if needed and then invoke with unmarshalled params.
	handler := w.Handler.CreateStack
	secure := w.Handler.SecureHandler
	err = secure(handler, ctx)

	return err
}

// GetStack converts echo context to params.

func (w *ServerInterfaceWrapper) GetStack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(APIKeyAuthScopes, []string{""})

	// Get the handler, get the secure handler if needed and then invoke with unmarshalled params.
	handler := w.Handler.GetStack
	secure := w.Handler.SecureHandler
	err = secure(handler, ctx)

	return err
}

// EchoRouter is an interface that wraps the methods of echo.Echo & echo.Group to provide a common interface
// for registering routes.
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/core/stacks", wrapper.ListStacks)
	router.POST(baseURL+"/core/stacks", wrapper.CreateStack)
	router.GET(baseURL+"/core/stacks/:slug", wrapper.GetStack)

}
