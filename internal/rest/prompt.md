## Context

To build a CRUD API using `sqlc` for database instructions, we need to generate an OpenAPI schema. This requires creating wrapper functions around `sqlc`-generated queries for the following reasons:

- API endpoints won't provide all function inputs (e.g., auto-generated `slug`, user-provided `password`).
- API requests may need adjustments for `sqlc` consumption.
- Type casting of SQL parameters might be necessary.

We'll analyze the `sqlc` generated code, with helper files provided, to create these wrappers.

### Files

- models.go

```go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package entities

import (
 "database/sql/driver"
 "encoding/json"
 "fmt"
 "time"

 "github.com/google/uuid"
 "github.com/jackc/pgx/v5/pgtype"
)

type EventProvider string

const (
 EventProviderGithub EventProvider = "github"
 EventProviderSlack  EventProvider = "slack"
)

func (e *EventProvider) Scan(src interface{}) error {
 switch s := src.(type) {
 case []byte:
  *e = EventProvider(s)
 case string:
  *e = EventProvider(s)
 default:
  return fmt.Errorf("unsupported scan type for EventProvider: %T", src)
 }
 return nil
}

type NullEventProvider struct {
 EventProvider EventProvider `json:"event_provider"`
 Valid         bool          `json:"valid"` // Valid is true if EventProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventProvider) Scan(value interface{}) error {
 if value == nil {
  ns.EventProvider, ns.Valid = "", false
  return nil
 }
 ns.Valid = true
 return ns.EventProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventProvider) Value() (driver.Value, error) {
 if !ns.Valid {
  return nil, nil
 }
 return string(ns.EventProvider), nil
}

type GithubInstallation struct {
 ID                  uuid.UUID   `json:"id"`
 CreatedAt           time.Time   `json:"created_at"`
 UpdatedAt           time.Time   `json:"updated_at"`
 OrgID               uuid.UUID   `json:"org_id"`
 InstallationID      int64       `json:"installation_id"`
 InstallationLogin   string      `json:"installation_login"`
 InstallationLoginID int64       `json:"installation_login_id"`
 InstallationType    pgtype.Text `json:"installation_type"`
 SenderID            int64       `json:"sender_id"`
 SenderLogin         string      `json:"sender_login"`
 Status              pgtype.Text `json:"status"`
}

type GithubOrg struct {
 ID             uuid.UUID `json:"id"`
 CreatedAt      time.Time `json:"created_at"`
 UpdatedAt      time.Time `json:"updated_at"`
 InstallationID uuid.UUID `json:"installation_id"`
 GithubOrgID    int64     `json:"github_org_id"`
 Name           string    `json:"name"`
}

type GithubRepo struct {
 ID             uuid.UUID   `json:"id"`
 CreatedAt      time.Time   `json:"created_at"`
 UpdatedAt      time.Time   `json:"updated_at"`
 RepoID         uuid.UUID   `json:"repo_id"`
 InstallationID uuid.UUID   `json:"installation_id"`
 GithubID       int64       `json:"github_id"`
 Name           string      `json:"name"`
 FullName       string      `json:"full_name"`
 Url            string      `json:"url"`
 IsActive       pgtype.Bool `json:"is_active"`
}

type GithubUser struct {
 ID          uuid.UUID   `json:"id"`
 CreatedAt   time.Time   `json:"created_at"`
 UpdatedAt   time.Time   `json:"updated_at"`
 UserID      pgtype.UUID `json:"user_id"`
 GithubID    int64       `json:"github_id"`
 GithubOrgID uuid.UUID   `json:"github_org_id"`
 Login       string      `json:"login"`
}

type Messaging struct {
 ID        uuid.UUID       `json:"id"`
 CreatedAt time.Time       `json:"created_at"`
 UpdatedAt time.Time       `json:"updated_at"`
 Provider  string          `json:"provider"`
 Kind      string          `json:"kind"`
 LinkTo    uuid.UUID       `json:"link_to"`
 Data      json.RawMessage `json:"data"`
}

type OauthAccount struct {
 ID                uuid.UUID          `json:"id"`
 CreatedAt         time.Time          `json:"created_at"`
 UpdatedAt         time.Time          `json:"updated_at"`
 UserID            uuid.UUID          `json:"user_id"`
 Provider          string             `json:"provider"`
 ProviderAccountID string             `json:"provider_account_id"`
 ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
 Type              pgtype.Text        `json:"type"`
}

type Org struct {
 ID        uuid.UUID `json:"id"`
 CreatedAt time.Time `json:"created_at"`
 UpdatedAt time.Time `json:"updated_at"`
 Name      string    `json:"name"`
 Slug      string    `json:"slug"`
}

type Repo struct {
 ID            uuid.UUID       `json:"id"`
 CreatedAt     time.Time       `json:"created_at"`
 UpdatedAt     time.Time       `json:"updated_at"`
 OrgID         uuid.UUID       `json:"org_id"`
 Name          string          `json:"name"`
 Provider      string          `json:"provider"`
 ProviderID    string          `json:"provider_id"`
 DefaultBranch pgtype.Text     `json:"default_branch"`
 IsMonorepo    pgtype.Bool     `json:"is_monorepo"`
 Threshold     pgtype.Int4     `json:"threshold"`
 StaleDuration pgtype.Interval `json:"stale_duration"`
}

type Team struct {
 ID        uuid.UUID `json:"id"`
 CreatedAt time.Time `json:"created_at"`
 UpdatedAt time.Time `json:"updated_at"`
 OrgID     uuid.UUID `json:"org_id"`
 Name      string    `json:"name"`
 Slug      string    `json:"slug"`
}

type TeamUser struct {
 ID        uuid.UUID   `json:"id"`
 CreatedAt time.Time   `json:"created_at"`
 UpdatedAt time.Time   `json:"updated_at"`
 TeamID    uuid.UUID   `json:"team_id"`
 UserID    uuid.UUID   `json:"user_id"`
 Role      pgtype.Text `json:"role"`
 IsActive  bool        `json:"is_active"`
 IsAdmin   bool        `json:"is_admin"`
}

type User struct {
 ID         uuid.UUID   `json:"id"`
 CreatedAt  time.Time   `json:"created_at"`
 UpdatedAt  time.Time   `json:"updated_at"`
 OrgID      uuid.UUID   `json:"org_id"`
 Email      string      `json:"email"`
 FirstName  pgtype.Text `json:"first_name"`
 LastName   pgtype.Text `json:"last_name"`
 Password   pgtype.Text `json:"password"`
 IsActive   bool        `json:"is_active"`
 IsVerified bool        `json:"is_verified"`
}
```

- errors.go

```go
package rest

import (
	"github.com/go-playground/validator/v10"
	"go.breu.io/quantm/internal/shared"
)

type (
	// APIError represents a generic API error.
	//
	// It includes the HTTP status code, a human-readable message, and additional information.
	APIError struct {
		ID      string    `json:"id"`      // Unique identifier for the error.
		Code    int       `json:"status"`  // HTTP status code of the error.
		Message string    `json:"message"` // Human-readable message describing the error.
		Info    ErrorInfo `json:"info"`    // Additional information about the error.
	}

	// ErrorInfo represents a map of key-value pairs providing additional information about an error.
	//
	// Example:
	//
	//     info := ErrorInfo{"field": "invalid value"}
	ErrorInfo map[string]string

	// BadRequestError represents a 400 Bad Request error.
	BadRequestError APIError
	// UnauthorizedError represents a 401 Unauthorized error.
	UnauthorizedError APIError
	// NotFoundError represents a 404 Not Found error.
	NotFoundError APIError
)

// Error implements the error interface for APIError.
func (e *APIError) Error() string {
	return e.Message
}

// SetInfo sets the ErrorInformation field of the APIError.
//
// Example:
//
//	err := NewBadRequestError("field", "invalid value")
//	err.SetInfo(ErrorInformation{"field": "invalid value"})
func (e *APIError) SetInfo(info ErrorInfo) *APIError {
	e.Info = info
	return e
}

// AddInfo adds a key-value pair to the ErrorInformation field of the APIError.
//
// Example:
//
//	err := NewBadRequestError()
//	err.AddInfo("field", "invalid value")
func (e *APIError) AddInfo(key, value string) *APIError {
	if e.Info == nil {
		e.Info = make(ErrorInfo)
	}

	e.Info[key] = value
	return e
}

// FormatValidationError formats a validator.ValidationErrors object into the ErrorInformation field.
//
// Example:
//
//	err := validator.New().Struct(struct{}{})
//	apiErr := NewBadRequestError()
//	apiErr.FormatValidationError(err)
func (e *APIError) FormatValidationError(err error) *APIError {
	valid, ok := err.(validator.ValidationErrors)
	if !ok {
		return e
	}

	for _, v := range valid {
		_ = e.AddInfo(v.Field(), v.Tag())
	}

	return e
}

// NewAPIError creates a new APIError instance.
//
// It takes the HTTP status code, a human-readable message, and optional key-value pairs for additional information.
//
// Example:
//
//	err := NewAPIError(400, "Bad Request", "field", "invalid value")
//	fmt.Println(err.Error()) // Output: Bad Request
func NewAPIError(code int, message string, args ...string) *APIError {
	extra := false
	if len(args)%2 != 0 {
		extra = true
	}

	info := make(ErrorInfo)

	for i := 0; i < len(args); i += 2 {
		info[args[i]] = args[i+1]
	}

	if extra {
		info["unknown"] = args[len(args)-1]
	}

	return &APIError{
		ID:      shared.Idempotent(),
		Code:    code,
		Message: message,
		Info:    info,
	}
}

// NewBadRequestError creates a new 400 Bad Request error.
//
// Example:
//
//	err := NewBadRequestError("field", "invalid value")
func NewBadRequestError(args ...string) *APIError {
	return NewAPIError(400, "Bad Request", args...)
}

// NewUnauthorizedError creates a new 401 Unauthorized error.
//
// Example:
//
//	err := NewUnauthorizedError("user_id", "123")
func NewUnauthorizedError(args ...string) *APIError {
	return NewAPIError(401, "Unauthorized", args...)
}

// NewNotFoundError creates a new 404 Not Found error.
//
// Example:
//
//	err := NewNotFoundError("user_id", "123")
func NewNotFoundError(args ...string) *APIError {
	return NewAPIError(404, "Not Found", args...)
}

// NewInternalServerError creates a new 500 Internal Server Error.
//
// Example:
//
//	err := NewInternalServerError("reason", "database error")
func NewInternalServerError(args ...string) *APIError {
	return NewAPIError(500, "Internal Server Error", args...)
}
```

### Example

For example, `sqlc` for org generates the following code `org.sql.go` for `org.sql`.

```go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: org.sql

package entities

import (
 "context"

 "github.com/google/uuid"
)

const createOrg = `-- name: CreateOrg :one
INSERT INTO orgs (name, slug)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, name, slug
`

type CreateOrgParams struct {
 Name string `json:"name"`
 Slug string `json:"slug"`
}

func (q *Queries) CreateOrg(ctx context.Context, arg CreateOrgParams) (Org, error) {
 row := q.db.QueryRow(ctx, createOrg, arg.Name, arg.Slug)
 var i Org
 err := row.Scan(
  &i.ID,
  &i.CreatedAt,
  &i.UpdatedAt,
  &i.Name,
  &i.Slug,
 )
 return i, err
}

const deleteOrg = `-- name: DeleteOrg :exec
DELETE FROM orgs
WHERE id = $1
`

func (q *Queries) DeleteOrg(ctx context.Context, id uuid.UUID) error {
 _, err := q.db.Exec(ctx, deleteOrg, id)
 return err
}

const updateOrg = `-- name: UpdateOrg :one
UPDATE orgs
SET name = $2, slug = $3
WHERE id = $1
RETURNING id, created_at, updated_at, name, slug
`

type UpdateOrgParams struct {
 ID   uuid.UUID `json:"id"`
 Name string    `json:"name"`
 Slug string    `json:"slug"`
}

func (q *Queries) UpdateOrg(ctx context.Context, arg UpdateOrgParams) (Org, error) {
 row := q.db.QueryRow(ctx, updateOrg, arg.ID, arg.Name, arg.Slug)
 var i Org
 err := row.Scan(
  &i.ID,
  &i.CreatedAt,
  &i.UpdatedAt,
  &i.Name,
  &i.Slug,
 )
 return i, err
}
```

In this case,

- `CreateOrgParams` for `sqlc` includes `slug` which we do not want.
- We do not want the API to have a delete endpoint.

The resulting wrapper `org.go` looks like.

```go
package rest

import (
 "context"

 "go.breu.io/quantm/internal/db"
 "go.breu.io/quantm/internal/db/entities"
)

type (
 CreateOrgRequest struct {
  Name string `json:"name"`
 }
)

// CreateOrg Create a new organization
func CreateOrg(ctx context.Context, req CreateOrgRequest) (entities.Org, error) {
 return db.Queries().CreateOrg(ctx, entities.CreateOrgParams{Name: req.Name, Slug: db.CreateSlug(req.Name)})
}
```

## Instructions

Keep your responses short and to the point.

1. **Function-by-Function Analysis:**  You will process each function generated by `sqlc` one at a time.
2. **Initial Question:** You will first print the function name and ask:
    - **Do you want this function `<function_name>` to be part of your REST API?**
3. **Mutate Request:** If I answer "yes" to the previous question, You will first print the input (struct or type) and the ask:
    - **Do you want to mutate the request for function `<function_name>`?**
    - If "yes," You will display the relevant `sqlc` function parameters (arguments) and ask:
        - **What changes should be made to the request parameters?**
    - If "no", you will create an alias for the input params like `type CreateUserRequest = entities.CreateUserParams` etc.
4. **Mutate Response:** If you answer "yes" to the previous question, You will then print the output struct and ask:
    - **Do you want to mutate the response for function `<function_name>`?**
    - If "yes," You will display the relevant `sqlc` function return type and ask:
        - **What changes should be made to the response?**
5. **Wrapper Generation:** Based on my answers, You will generate the appropriate REST API wrapper function and then print it for me to review. Then you will ask me the question.
    - **Is this the expected response**
    - If "no", you will ask me the following question until I am happy:
      - **What changes should be made to the wrapper**
6. **Repeat:** This process will repeat for each function generated by `sqlc`.
